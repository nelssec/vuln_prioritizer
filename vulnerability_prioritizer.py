#!/usr/bin/env python3
"""
Vulnerability Prioritization Engine
Combines CVSS, EPSS, threat intelligence, and business context 
to create actionable patch prioritization
"""

import json
import csv
import requests
from datetime import datetime, timedelta
from typing import Dict, List, Tuple, Optional
from dataclasses import dataclass, field, asdict
from enum import Enum
import logging

# Setup logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class AssetCriticality(Enum):
    """Asset criticality levels"""
    CRITICAL = 5  # Customer-facing, revenue-generating
    HIGH = 4      # Production systems
    MEDIUM = 3    # Internal systems
    LOW = 2       # Development/Test
    MINIMAL = 1   # Lab/Sandbox

class ExposureLevel(Enum):
    """Network exposure levels"""
    INTERNET = 5  # Internet-facing
    EXTRANET = 4  # Partner-facing
    INTERNAL = 3  # Internal network
    SEGMENTED = 2 # Segmented network
    ISOLATED = 1  # Air-gapped

class DataSensitivity(Enum):
    """Data classification levels"""
    SECRET = 5    # PII, PHI, PCI, etc.
    CONFIDENTIAL = 4
    INTERNAL = 3
    PUBLIC = 2
    NONE = 1

@dataclass
class ThreatIntelligence:
    """Threat intelligence data"""
    in_the_wild: bool = False
    exploit_available: bool = False
    ransomware_known: bool = False
    apt_activity: bool = False
    trending: bool = False
    threat_score: float = 0.0

@dataclass
class Vulnerability:
    """Complete vulnerability profile"""
    cve_id: str
    description: str = ""
    
    # CVSS Scores
    cvss_score: float = 0.0
    cvss_version: str = "3.1"
    cvss_vector: str = ""
    severity: str = "NONE"
    
    # EPSS Score (Exploit Prediction Scoring System)
    epss_score: float = 0.0
    epss_percentile: float = 0.0
    
    # Asset Context
    affected_assets: List[str] = field(default_factory=list)
    asset_criticality: AssetCriticality = AssetCriticality.MEDIUM
    exposure_level: ExposureLevel = ExposureLevel.INTERNAL
    data_sensitivity: DataSensitivity = DataSensitivity.INTERNAL
    
    # Threat Intelligence
    threat_intel: ThreatIntelligence = field(default_factory=ThreatIntelligence)
    
    # Operational Context
    patch_available: bool = False
    patch_complexity: str = "MEDIUM"  # LOW, MEDIUM, HIGH
    compensating_controls: bool = False
    
    # Calculated Risk Score
    risk_score: float = 0.0
    priority: str = "MEDIUM"
    
    # Metadata
    published_date: str = ""
    last_modified: str = ""
    days_since_published: int = 0

class VulnerabilityPrioritizer:
    """Main prioritization engine"""
    
    def __init__(self):
        self.vulnerabilities: List[Vulnerability] = []
        self.threat_feeds: Dict[str, str] = {
            'cisa_kev': 'https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json',
            'epss': 'https://api.first.org/data/v1/epss'
        }
        
    def calculate_risk_score(self, vuln: Vulnerability) -> float:
        """
        Calculate comprehensive risk score based on multiple factors
        This is where the magic happens - combining all context
        """
        
        # Base score from CVSS (normalized to 0-100)
        base_score = vuln.cvss_score * 10
        
        # EPSS weight (exploit probability)
        epss_weight = vuln.epss_score * 30  # Max 30 points
        
        # Asset context weight (max 30 points)
        asset_weight = (
            (vuln.asset_criticality.value * 2) +  # Max 10
            (vuln.exposure_level.value * 2) +      # Max 10
            (vuln.data_sensitivity.value * 2)      # Max 10
        )
        
        # Threat intelligence weight (max 40 points)
        threat_weight = 0
        if vuln.threat_intel.in_the_wild:
            threat_weight += 15
        if vuln.threat_intel.exploit_available:
            threat_weight += 10
        if vuln.threat_intel.ransomware_known:
            threat_weight += 8
        if vuln.threat_intel.apt_activity:
            threat_weight += 5
        if vuln.threat_intel.trending:
            threat_weight += 2
            
        # Temporal weight (decay over time if no exploitation)
        temporal_weight = 0
        if vuln.days_since_published < 30:
            temporal_weight = 10
        elif vuln.days_since_published < 90:
            temporal_weight = 5
        
        # Mitigation factors (reduce score)
        mitigation_reduction = 0
        if vuln.compensating_controls:
            mitigation_reduction = 15
        if vuln.patch_complexity == "HIGH":
            mitigation_reduction -= 5  # Harder to patch = higher priority
        
        # Calculate final score (0-100 scale)
        final_score = min(100, max(0,
            (base_score * 0.20) +  # CVSS contributes 20%
            (epss_weight * 0.25) +  # EPSS contributes 25%
            (asset_weight * 0.20) + # Asset context 20%
            (threat_weight * 0.25) + # Threat intel 25%
            (temporal_weight * 0.10) - # Temporal 10%
            mitigation_reduction
        ))
        
        return round(final_score, 2)
    
    def determine_priority(self, risk_score: float) -> str:
        """Determine priority based on risk score"""
        if risk_score >= 85:
            return "CRITICAL"
        elif risk_score >= 70:
            return "HIGH"
        elif risk_score >= 50:
            return "MEDIUM"
        elif risk_score >= 30:
            return "LOW"
        else:
            return "MINIMAL"
    
    def fetch_cisa_kev(self) -> Dict[str, bool]:
        """Fetch CISA Known Exploited Vulnerabilities"""
        try:
            response = requests.get(self.threat_feeds['cisa_kev'], timeout=10)
            data = response.json()
            kev_dict = {}
            for vuln in data.get('vulnerabilities', []):
                kev_dict[vuln['cveID']] = True
            logger.info(f"Loaded {len(kev_dict)} CISA KEV entries")
            return kev_dict
        except Exception as e:
            logger.error(f"Error fetching CISA KEV: {e}")
            return {}
    
    def fetch_epss_scores(self, cve_list: List[str]) -> Dict[str, Dict]:
        """Fetch EPSS scores for CVE list"""
        epss_data = {}
        try:
            # EPSS API typically requires specific formatting
            # This is a simplified version - real implementation would batch properly
            for cve in cve_list[:10]:  # Limit for demo
                # Simulated EPSS data - replace with actual API call
                epss_data[cve] = {
                    'epss': 0.15 + (hash(cve) % 70) / 100,  # Simulated score
                    'percentile': 0.20 + (hash(cve) % 60) / 100
                }
            logger.info(f"Loaded EPSS scores for {len(epss_data)} CVEs")
        except Exception as e:
            logger.error(f"Error fetching EPSS scores: {e}")
        return epss_data
    
    def enrich_with_threat_intel(self, vuln: Vulnerability, cisa_kev: Dict) -> None:
        """Enrich vulnerability with threat intelligence"""
        # Check CISA KEV
        if vuln.cve_id in cisa_kev:
            vuln.threat_intel.in_the_wild = True
            vuln.threat_intel.exploit_available = True
        
        # Simulate additional threat intel sources
        # In production, integrate with real threat feeds
        if "remote code" in vuln.description.lower():
            vuln.threat_intel.threat_score += 2.0
        if "authentication" in vuln.description.lower() and "bypass" in vuln.description.lower():
            vuln.threat_intel.threat_score += 1.5
        if vuln.cvss_score >= 9.0:
            vuln.threat_intel.trending = True
    
    def prioritize_vulnerabilities(self, vulns: List[Vulnerability]) -> List[Vulnerability]:
        """Main prioritization workflow"""
        logger.info(f"Starting prioritization for {len(vulns)} vulnerabilities")
        
        # Fetch threat intelligence data
        cisa_kev = self.fetch_cisa_kev()
        cve_list = [v.cve_id for v in vulns]
        epss_scores = self.fetch_epss_scores(cve_list)
        
        # Process each vulnerability
        for vuln in vulns:
            # Add EPSS scores
            if vuln.cve_id in epss_scores:
                vuln.epss_score = epss_scores[vuln.cve_id]['epss']
                vuln.epss_percentile = epss_scores[vuln.cve_id]['percentile']
            
            # Enrich with threat intelligence
            self.enrich_with_threat_intel(vuln, cisa_kev)
            
            # Calculate comprehensive risk score
            vuln.risk_score = self.calculate_risk_score(vuln)
            vuln.priority = self.determine_priority(vuln.risk_score)
        
        # Sort by risk score (highest first)
        vulns.sort(key=lambda x: x.risk_score, reverse=True)
        
        logger.info("Prioritization complete")
        return vulns
    
    def generate_report(self, vulns: List[Vulnerability], top_n: int = 10) -> str:
        """Generate prioritized patch report"""
        report = []
        report.append("=" * 80)
        report.append("VULNERABILITY PRIORITIZATION REPORT")
        report.append(f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        report.append("=" * 80)
        report.append("")
        
        # Summary statistics
        priority_counts = {}
        for vuln in vulns:
            priority_counts[vuln.priority] = priority_counts.get(vuln.priority, 0) + 1
        
        report.append("SUMMARY")
        report.append("-" * 40)
        report.append(f"Total Vulnerabilities: {len(vulns)}")
        for priority in ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW', 'MINIMAL']:
            count = priority_counts.get(priority, 0)
            if count > 0:
                report.append(f"  {priority}: {count}")
        report.append("")
        
        # Top priority vulnerabilities
        report.append(f"TOP {top_n} PRIORITY VULNERABILITIES")
        report.append("-" * 40)
        
        for i, vuln in enumerate(vulns[:top_n], 1):
            report.append(f"\n{i}. {vuln.cve_id} - PRIORITY: {vuln.priority}")
            report.append(f"   Risk Score: {vuln.risk_score}/100")
            report.append(f"   CVSS: {vuln.cvss_score} | EPSS: {vuln.epss_score:.2%}")
            report.append(f"   Assets: {', '.join(vuln.affected_assets[:3])}")
            
            # Risk factors
            risk_factors = []
            if vuln.threat_intel.in_the_wild:
                risk_factors.append("Exploited in Wild")
            if vuln.threat_intel.exploit_available:
                risk_factors.append("Exploit Available")
            if vuln.exposure_level == ExposureLevel.INTERNET:
                risk_factors.append("Internet Exposed")
            if vuln.asset_criticality == AssetCriticality.CRITICAL:
                risk_factors.append("Critical Asset")
            if vuln.data_sensitivity == DataSensitivity.SECRET:
                risk_factors.append("Sensitive Data")
            
            if risk_factors:
                report.append(f"   Risk Factors: {' | '.join(risk_factors)}")
            
            # Mitigation
            if vuln.patch_available:
                complexity_emoji = {"LOW": "✅", "MEDIUM": "⚠️", "HIGH": "🔴"}
                report.append(f"   Patch: Available {complexity_emoji.get(vuln.patch_complexity, '')} ({vuln.patch_complexity} complexity)")
            else:
                report.append("   Patch: ❌ Not Available")
            
            if vuln.compensating_controls:
                report.append("   Compensating Controls: ✓ In Place")
        
        report.append("\n" + "=" * 80)
        report.append("RECOMMENDATIONS")
        report.append("-" * 40)
        report.append("1. Address CRITICAL priority vulnerabilities within 24 hours")
        report.append("2. Address HIGH priority vulnerabilities within 7 days")
        report.append("3. Review compensating controls for vulnerabilities without patches")
        report.append("4. Focus on internet-facing assets with sensitive data first")
        
        return "\n".join(report)
    
    def export_to_csv(self, vulns: List[Vulnerability], filename: str = "vulnerability_priorities.csv"):
        """Export prioritized list to CSV"""
        with open(filename, 'w', newline='') as csvfile:
            fieldnames = [
                'cve_id', 'priority', 'risk_score', 'cvss_score', 'epss_score',
                'asset_criticality', 'exposure_level', 'in_the_wild', 
                'exploit_available', 'patch_available', 'affected_assets'
            ]
            writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
            
            writer.writeheader()
            for vuln in vulns:
                writer.writerow({
                    'cve_id': vuln.cve_id,
                    'priority': vuln.priority,
                    'risk_score': vuln.risk_score,
                    'cvss_score': vuln.cvss_score,
                    'epss_score': vuln.epss_score,
                    'asset_criticality': vuln.asset_criticality.name,
                    'exposure_level': vuln.exposure_level.name,
                    'in_the_wild': vuln.threat_intel.in_the_wild,
                    'exploit_available': vuln.threat_intel.exploit_available,
                    'patch_available': vuln.patch_available,
                    'affected_assets': ';'.join(vuln.affected_assets[:5])
                })
        logger.info(f"Exported {len(vulns)} vulnerabilities to {filename}")

def create_sample_vulnerabilities() -> List[Vulnerability]:
    """Create sample vulnerability data for demonstration"""
    sample_vulns = [
        Vulnerability(
            cve_id="CVE-2024-12345",
            description="Remote code execution in web application framework",
            cvss_score=9.8,
            severity="CRITICAL",
            affected_assets=["web-prod-01", "web-prod-02", "api-gateway"],
            asset_criticality=AssetCriticality.CRITICAL,
            exposure_level=ExposureLevel.INTERNET,
            data_sensitivity=DataSensitivity.SECRET,
            patch_available=True,
            patch_complexity="MEDIUM",
            days_since_published=5
        ),
        Vulnerability(
            cve_id="CVE-2024-23456",
            description="SQL injection in customer database interface",
            cvss_score=8.5,
            severity="HIGH",
            affected_assets=["db-prod-01", "db-prod-02"],
            asset_criticality=AssetCriticality.CRITICAL,
            exposure_level=ExposureLevel.INTERNAL,
            data_sensitivity=DataSensitivity.SECRET,
            patch_available=True,
            patch_complexity="LOW",
            days_since_published=15
        ),
        Vulnerability(
            cve_id="CVE-2024-34567",
            description="Authentication bypass in admin portal",
            cvss_score=7.5,
            severity="HIGH",
            affected_assets=["admin-portal-01"],
            asset_criticality=AssetCriticality.HIGH,
            exposure_level=ExposureLevel.EXTRANET,
            data_sensitivity=DataSensitivity.CONFIDENTIAL,
            patch_available=False,
            compensating_controls=True,
            days_since_published=30
        ),
        Vulnerability(
            cve_id="CVE-2024-45678",
            description="Denial of service in logging service",
            cvss_score=5.3,
            severity="MEDIUM",
            affected_assets=["log-server-01", "log-server-02"],
            asset_criticality=AssetCriticality.MEDIUM,
            exposure_level=ExposureLevel.INTERNAL,
            data_sensitivity=DataSensitivity.INTERNAL,
            patch_available=True,
            patch_complexity="LOW",
            days_since_published=60
        ),
        Vulnerability(
            cve_id="CVE-2024-56789",
            description="Information disclosure in test application",
            cvss_score=4.2,
            severity="MEDIUM",
            affected_assets=["test-app-01"],
            asset_criticality=AssetCriticality.LOW,
            exposure_level=ExposureLevel.ISOLATED,
            data_sensitivity=DataSensitivity.PUBLIC,
            patch_available=True,
            patch_complexity="LOW",
            days_since_published=120
        ),
        Vulnerability(
            cve_id="CVE-2024-67890",
            description="Privilege escalation in internal tool",
            cvss_score=6.8,
            severity="MEDIUM",
            affected_assets=["internal-tool-01", "internal-tool-02"],
            asset_criticality=AssetCriticality.MEDIUM,
            exposure_level=ExposureLevel.INTERNAL,
            data_sensitivity=DataSensitivity.CONFIDENTIAL,
            patch_available=True,
            patch_complexity="HIGH",
            days_since_published=45
        ),
        Vulnerability(
            cve_id="CVE-2024-78901",
            description="Cross-site scripting in customer portal",
            cvss_score=6.1,
            severity="MEDIUM",
            affected_assets=["customer-portal-01", "customer-portal-02"],
            asset_criticality=AssetCriticality.HIGH,
            exposure_level=ExposureLevel.INTERNET,
            data_sensitivity=DataSensitivity.CONFIDENTIAL,
            patch_available=True,
            patch_complexity="MEDIUM",
            days_since_published=10
        ),
        Vulnerability(
            cve_id="CVE-2024-89012",
            description="Buffer overflow in legacy system",
            cvss_score=8.8,
            severity="HIGH",
            affected_assets=["legacy-sys-01"],
            asset_criticality=AssetCriticality.LOW,
            exposure_level=ExposureLevel.SEGMENTED,
            data_sensitivity=DataSensitivity.INTERNAL,
            patch_available=False,
            compensating_controls=True,
            days_since_published=200
        )
    ]
    
    # Simulate some vulnerabilities being in CISA KEV
    sample_vulns[0].threat_intel.in_the_wild = True
    sample_vulns[0].threat_intel.exploit_available = True
    sample_vulns[0].threat_intel.ransomware_known = True
    
    sample_vulns[1].threat_intel.exploit_available = True
    sample_vulns[2].threat_intel.trending = True
    
    return sample_vulns

def main():
    """Main demonstration"""
    print("\n Vulnerability Prioritization Engine")
    print("=" * 50)
    print("Demonstrating context-aware patch prioritization")
    print("=" * 50 + "\n")
    
    # Initialize prioritizer
    prioritizer = VulnerabilityPrioritizer()
    
    # Create sample vulnerabilities
    print("Loading vulnerability data...")
    vulnerabilities = create_sample_vulnerabilities()
    print(f"   Loaded {len(vulnerabilities)} vulnerabilities\n")
    
    # Show before prioritization (CVSS only)
    print("BEFORE: Ranking by CVSS Score Only")
    print("-" * 40)
    vulns_by_cvss = sorted(vulnerabilities, key=lambda x: x.cvss_score, reverse=True)
    for i, vuln in enumerate(vulns_by_cvss[:5], 1):
        print(f"{i}. {vuln.cve_id}: CVSS {vuln.cvss_score} ({vuln.severity})")
    
    print("\n🔍 Enriching with threat intelligence...")
    print("Fetching EPSS scores...")
    print("Analyzing business context...")
    print("Calculating risk scores...\n")
    
    # Prioritize with full context
    prioritized = prioritizer.prioritize_vulnerabilities(vulnerabilities)
    
    # Show after prioritization
    print("AFTER: Context-Aware Prioritization")
    print("-" * 40)
    for i, vuln in enumerate(prioritized[:5], 1):
        print(f"{i}. {vuln.cve_id}: Risk Score {vuln.risk_score}/100 ({vuln.priority})")
        print(f"   CVSS: {vuln.cvss_score} | Context factors adjusted priority")
    
    # Generate full report
    print("\nGenerating detailed report...\n")
    report = prioritizer.generate_report(prioritized)
    print(report)
    
    # Export to CSV
    csv_filename = "/home/claude/prioritized_vulnerabilities.csv"
    prioritizer.export_to_csv(prioritized, csv_filename)
    print(f"\nExported detailed results to {csv_filename}")
    
    # Show key insight
    print("\n" + "=" * 50)
    print("KEY INSIGHT:")
    print("Notice how vulnerabilities changed position when we added:")
    print("- Asset criticality and exposure")
    print("- Threat intelligence (CISA KEV, exploits)")
    print("- EPSS probability scores")
    print("- Business context and data sensitivity")
    print("\nThis demonstrates why CVSS alone isn't enough!")
    print("=" * 50)

if __name__ == "__main__":
    main()
